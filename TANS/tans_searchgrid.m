function [SubSampledSearchGrid,FullSearchGrid] = tans_searchgrid(TargetNetworkPatch,PialSurfs,SkinVol,SkinSurf,SkinDistanceMatrix,GridSpacing,SearchGridRadius,OutDir,Paths)
% cjl; cjl2007@med.cornell.edu;
%
% The inputs to the function are:
% TargetPatch: A 59412 (the number of cortical vertices) x 1 logical array representing the target network patch. This input is generated by the tans_roi function.
% PialSurfs: Paths to low (32k) dimensional FS_LR pial surfaces (Cell array of strings, PialSurfs{1} = path to LH, PialSurfs{2} = path to RH).
% SkinVol: Path to the volumetric skin segmentation volume (string). 
% SkinSurf: Path to the skin surface geometry file (string). 
% SkinDistanceMatrix: Path to the skin distance matrix (string). This is a .m file. 
% SearchGridRadius: Radius of the search grid on the scalp directly above the centroid of the target network patch. 
% GridSpacing: The (approximate) distance between pairs of vertices in the search grid. 
% OutDir: Path to the output folder (string).
% Paths: Paths to folders that must be added to Matlab search path (cell array of strings). 

% add some directories 
% to the search path;
for i = 1:length(Paths)
addpath(genpath(Paths{i})); % 
end

rng(44); % for reproducibility;

% make search grid directory;
mkdir([OutDir '/SearchGrid/']);

% load pial surfaces; 
LH = gifti(PialSurfs{1});
RH = gifti(PialSurfs{2});

% extract coordinates for all cortical vertices 
SurfaceCoords = [LH.vertices; RH.vertices]; % combine hemipsheres 
NotMedialWall = TargetNetworkPatch.brainstructure > 0 & TargetNetworkPatch.brainstructure < 3;
NotMedialWall = NotMedialWall(1:size(SurfaceCoords,1));
SurfaceCoords = SurfaceCoords(NotMedialWall,:);

% create a search grid above the target network patch centroid;

% read in the skin mesh file;
AllSkin = gifti(SkinSurf);

% identify the ROI centroid, calculate distance to scalp, write out metric file;
system(['wb_command -volume-to-surface-mapping ' SkinVol ' ' SkinSurf ' ' OutDir '/SearchGrid/DistanceToROI.shape.gii -trilinear']);
G = gifti([OutDir '/SearchGrid/DistanceToROI.shape.gii']); G.cdata = zeros(size(G.cdata)); % blank slate
G.cdata = pdist2(AllSkin.vertices,mean(SurfaceCoords(TargetNetworkPatch.data==1,:))); % log the distances to ROI centroid
save(G,[OutDir '/SearchGrid/DistanceToROI.shape.gii']); % write out the metric file

% create a metric file showing the full search grid;
G.cdata(G.cdata>=SearchGridRadius) = 0; G.cdata(G.cdata~=0) = 1;
save(G,[OutDir '/SearchGrid/FullSearchGrid.shape.gii']); % 

% full search grid 
% coordinates & vertices;
SearchGridVertices = find(G.cdata~=0);
FullSearchGrid = AllSkin.vertices(SearchGridVertices,:); % 

% load distance matrix containing 
% vertex to vertex distances in geodesic space;
D = smartload(SkinDistanceMatrix);

% preallocate neighbors variable;
V = nan(size(SearchGridVertices,1),10);

% sweep through the full search grid
for i = 1:size(SearchGridVertices,1)
    tmp = find(D(SearchGridVertices(i),:) <= GridSpacing);
    V(i,1:length(tmp)) = tmp;
end

% preallocate;
SubSample = [];
Neighbors = [];

% sweep all the
% cortical vertices
for i = 1:size(V,1)
    if ~ismember(SearchGridVertices(i),Neighbors)
        SubSample = [SubSample SearchGridVertices(i)];
        Neighbors = [Neighbors V(i,2:end)];
    end
end

% this is a sensible subsampling of the
% full search grid that is suggested for following analyses
SubSampledSearchGrid = AllSkin.vertices(SubSample,:); 

% create a metric file showing the subsampled search grid
G = gifti([OutDir '/SearchGrid/FullSearchGrid.shape.gii']); 
G.cdata = zeros(size(G.cdata)); % blank slate;
G.cdata(SubSample) = 1:length(SubSample); % log serial numbers
save(G,[OutDir '/SearchGrid/SubSampledSearchGrid.shape.gii']); % write out the metric file

% save some variables;
save([OutDir '/SearchGrid/SubSampledSearchGrid'],'SubSampledSearchGrid');
save([OutDir '/SearchGrid/FullSearchGrid'],'FullSearchGrid');

end

%
function out = smartload(matfile)

out = load(matfile);
names = fieldnames(out);
out = eval(['out.' names{1}]);

end